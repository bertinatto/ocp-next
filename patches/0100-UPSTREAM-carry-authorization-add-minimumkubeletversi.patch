From 37261b24a280e52a1126ce7bf8b9158d3858e3b1 Mon Sep 17 00:00:00 2001
From: Peter Hunt <pehunt@redhat.com>
Date: Fri, 4 Oct 2024 14:53:39 -0400
Subject: [PATCH] UPSTREAM: <carry>: authorization: add minimumkubeletversion
 package

MinimumKubeletVersion is a way for an admin to declare that nodes any older than the
minimum version cannot authorize with the apiserver. This effectively prevents them from joining.

Doing so means the apiservers can trust newer features are usable on clusters with version skews

Signed-off-by: Peter Hunt <pehunt@redhat.com>
---
 cmd/kube-apiserver/app/config.go              |  15 ++
 .../minimum_kubelet_version.go                |  90 ++++++++
 .../minimum_kubelet_version_test.go           | 193 ++++++++++++++++++
 3 files changed, 298 insertions(+)
 create mode 100644 openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version.go
 create mode 100644 openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version_test.go

diff --git a/cmd/kube-apiserver/app/config.go b/cmd/kube-apiserver/app/config.go
index 7f03d42f9d8..f1272dbdcf7 100644
--- a/cmd/kube-apiserver/app/config.go
+++ b/cmd/kube-apiserver/app/config.go
@@ -23,8 +23,12 @@ import (
 	aggregatorapiserver "k8s.io/kube-aggregator/pkg/apiserver"
 	aggregatorscheme "k8s.io/kube-aggregator/pkg/apiserver/scheme"
 
+	"k8s.io/apiserver/pkg/authorization/union"
 	"k8s.io/kubernetes/cmd/kube-apiserver/app/options"
+	"k8s.io/kubernetes/openshift-kube-apiserver/authorization/minimumkubeletversion"
+	"k8s.io/kubernetes/openshift-kube-apiserver/enablement"
 	"k8s.io/kubernetes/pkg/api/legacyscheme"
+	"k8s.io/kubernetes/pkg/auth/nodeidentifier"
 	"k8s.io/kubernetes/pkg/controlplane"
 	controlplaneapiserver "k8s.io/kubernetes/pkg/controlplane/apiserver"
 	generatedopenapi "k8s.io/kubernetes/pkg/generated/openapi"
@@ -86,6 +90,17 @@ func NewConfig(opts options.CompletedOptions) (*Config, error) {
 		return nil, err
 	}
 
+	if ocfg := enablement.OpenshiftConfig(); ocfg != nil {
+		// Add MinimumKubeletVerison authorizer, to block a node from being able to access most resources if it's not new enough.
+		// We must do so here instead of in pkg/apiserver because it relies on a node informer, which is not present in generic control planes.
+		genericConfig.Authorization.Authorizer = union.New(genericConfig.Authorization.Authorizer, minimumkubeletversion.NewMinimumKubeletVersion(
+			ocfg.MinimumKubeletVersion,
+			nodeidentifier.NewDefaultNodeIdentifier(),
+			versionedInformers.Core().V1().Nodes().Informer(),
+			versionedInformers.Core().V1().Nodes().Lister(),
+		))
+	}
+
 	kubeAPIs, serviceResolver, pluginInitializer, err := CreateKubeAPIServerConfig(opts, genericConfig, versionedInformers, storageFactory)
 	if err != nil {
 		return nil, err
diff --git a/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version.go b/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version.go
new file mode 100644
index 00000000000..56218410b0e
--- /dev/null
+++ b/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version.go
@@ -0,0 +1,90 @@
+package minimumkubeletversion
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/blang/semver/v4"
+	nodelib "github.com/openshift/library-go/pkg/apiserver/node"
+	authorizationv1 "k8s.io/api/authorization/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	v1listers "k8s.io/client-go/listers/core/v1"
+	cache "k8s.io/client-go/tools/cache"
+	api "k8s.io/kubernetes/pkg/apis/core"
+	"k8s.io/kubernetes/pkg/auth/nodeidentifier"
+)
+
+type minimumKubeletVersionAuth struct {
+	nodeIdentifier          nodeidentifier.NodeIdentifier
+	nodeLister              v1listers.NodeLister
+	minVersion              *semver.Version
+	hasNodeInformerSyncedFn func() bool // factored for unit tests
+}
+
+// Creates a new minimumKubeletVersionAuth object, which is an authorizer that checks
+// whether nodes are new enough to be authorized.
+func NewMinimumKubeletVersion(minVersionStr string,
+	nodeIdentifier nodeidentifier.NodeIdentifier,
+	nodeInformer cache.SharedIndexInformer,
+	nodeLister v1listers.NodeLister,
+) *minimumKubeletVersionAuth {
+	var minVersionPtr *semver.Version
+	if len(minVersionStr) != 0 {
+		v := semver.MustParse(minVersionStr)
+		minVersionPtr = &v
+	}
+
+	return &minimumKubeletVersionAuth{
+		nodeIdentifier:          nodeIdentifier,
+		nodeLister:              nodeLister,
+		hasNodeInformerSyncedFn: nodeInformer.HasSynced,
+		minVersion:              minVersionPtr,
+	}
+}
+
+func (m *minimumKubeletVersionAuth) Authorize(ctx context.Context, attrs authorizer.Attributes) (authorizer.Decision, string, error) {
+	if m.minVersion == nil {
+		return authorizer.DecisionNoOpinion, "", nil
+	}
+
+	nodeName, isNode := m.nodeIdentifier.NodeIdentity(attrs.GetUser())
+	if !isNode {
+		// ignore requests from non-nodes
+		return authorizer.DecisionNoOpinion, "", nil
+	}
+
+	if len(nodeName) == 0 {
+		return authorizer.DecisionNoOpinion, fmt.Sprintf("unknown node for user %q", attrs.GetUser().GetName()), nil
+	}
+
+	// Short-circut if "subjectaccessreviews", or a "get" or "update" on the node object.
+	// Regardless of kubelet version, it should be allowed to do these things.
+	if attrs.IsResourceRequest() {
+		requestResource := schema.GroupResource{Group: attrs.GetAPIGroup(), Resource: attrs.GetResource()}
+		switch requestResource {
+		case api.Resource("nodes"):
+			if v := attrs.GetVerb(); v == "get" || v == "update" {
+				return authorizer.DecisionNoOpinion, "", nil
+			}
+		// TODO(haircommander): do we need other flavors of access reviews here?
+		case authorizationv1.Resource("subjectaccessreviews"):
+			return authorizer.DecisionNoOpinion, "", nil
+		}
+	}
+
+	if !m.hasNodeInformerSyncedFn() {
+		return authorizer.DecisionNoOpinion, fmt.Sprintf("node informer not synced, cannot check if node %s is new enough", nodeName), nil
+	}
+
+	node, err := m.nodeLister.Get(nodeName)
+	if err != nil {
+		return authorizer.DecisionNoOpinion, fmt.Sprintf("failed to get node %s: %v", nodeName, err), nil
+	}
+
+	if err := nodelib.IsNodeTooOld(node, m.minVersion); err != nil {
+		return authorizer.DecisionDeny, err.Error(), nil
+	}
+
+	return authorizer.DecisionNoOpinion, "", nil
+}
diff --git a/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version_test.go b/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version_test.go
new file mode 100644
index 00000000000..43c8e00cd29
--- /dev/null
+++ b/openshift-kube-apiserver/authorization/minimumkubeletversion/minimum_kubelet_version_test.go
@@ -0,0 +1,193 @@
+package minimumkubeletversion
+
+import (
+	"context"
+	"strings"
+	"testing"
+
+	"github.com/blang/semver/v4"
+	authorizationv1 "k8s.io/api/authorization/v1"
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apiserver/pkg/authentication/user"
+	kauthorizer "k8s.io/apiserver/pkg/authorization/authorizer"
+	"k8s.io/client-go/informers"
+	"k8s.io/client-go/kubernetes/fake"
+	"k8s.io/kubernetes/pkg/auth/nodeidentifier"
+	"k8s.io/kubernetes/pkg/controller"
+)
+
+func TestAuthorize(t *testing.T) {
+	nodeUser := &user.DefaultInfo{Name: "system:node:node0", Groups: []string{"system:nodes"}}
+
+	testCases := []struct {
+		name            string
+		minVersion      string
+		attributes      kauthorizer.AttributesRecord
+		expectedAllowed kauthorizer.Decision
+		expectedErr     string
+		expectedMsg     string
+		node            *v1.Node
+	}{
+		{
+			name:            "no version",
+			minVersion:      "",
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			expectedErr:     "",
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name"}},
+		},
+		{
+			name:       "user not a node",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            &user.DefaultInfo{Name: "name"},
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"}},
+		},
+		{
+			name:       "skips if subjectaccessreviews",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+				Resource:        "subjectaccessreviews",
+				APIGroup:        authorizationv1.GroupName,
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"}},
+		},
+		{
+			name:       "skips if get node",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+				Resource:        "nodes",
+				Verb:            "get",
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"}},
+		},
+		{
+			name:       "skips if update nodes",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+				Resource:        "nodes",
+				Verb:            "update",
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"}},
+		},
+		{
+			name:       "fail if update node not found",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			expectedMsg:     `failed to get node node0: node "node0" not found`,
+			node:            &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node1"}},
+		},
+		{
+			name:       "skip if bogus kubelet version",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+			},
+			expectedAllowed: kauthorizer.DecisionDeny,
+			expectedMsg:     `failed to parse node version bogus: No Major.Minor.Patch elements found`,
+			node: &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"},
+				Status: v1.NodeStatus{
+					NodeInfo: v1.NodeSystemInfo{
+						KubeletVersion: "bogus",
+					},
+				}},
+		},
+		{
+			name:       "deny if too low version",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+			},
+			expectedAllowed: kauthorizer.DecisionDeny,
+			expectedMsg:     `kubelet version is outdated: kubelet version is 1.29.8, which is lower than minimumKubeletVersion of 1.30.0`,
+			node: &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"},
+				Status: v1.NodeStatus{
+					NodeInfo: v1.NodeSystemInfo{
+						KubeletVersion: "v1.29.8-20+15d27f9ba1c119",
+					},
+				}},
+		},
+		{
+			name:       "accept if high enough version",
+			minVersion: "1.30.0",
+			attributes: kauthorizer.AttributesRecord{
+				ResourceRequest: true,
+				Namespace:       "ns",
+				User:            nodeUser,
+			},
+			expectedAllowed: kauthorizer.DecisionNoOpinion,
+			node: &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node0"},
+				Status: v1.NodeStatus{
+					NodeInfo: v1.NodeSystemInfo{
+						KubeletVersion: "1.30.0",
+					},
+				}},
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			fakeInformerFactory := informers.NewSharedInformerFactory(&fake.Clientset{}, controller.NoResyncPeriodFunc())
+			fakeNodeInformer := fakeInformerFactory.Core().V1().Nodes()
+			fakeNodeInformer.Informer().GetStore().Add(tc.node)
+			var minVersion *semver.Version
+			if tc.minVersion != "" {
+				v := semver.MustParse(tc.minVersion)
+				minVersion = &v
+			}
+
+			authorizer := &minimumKubeletVersionAuth{
+				nodeIdentifier: nodeidentifier.NewDefaultNodeIdentifier(),
+				nodeLister:     fakeNodeInformer.Lister(),
+				minVersion:     minVersion,
+				hasNodeInformerSyncedFn: func() bool {
+					return true
+				},
+			}
+
+			actualAllowed, actualMsg, actualErr := authorizer.Authorize(context.TODO(), tc.attributes)
+			switch {
+			case len(tc.expectedErr) == 0 && actualErr == nil:
+			case len(tc.expectedErr) == 0 && actualErr != nil:
+				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
+			case len(tc.expectedErr) != 0 && actualErr == nil:
+				t.Errorf("%s: missing error: %v", tc.name, tc.expectedErr)
+			case len(tc.expectedErr) != 0 && actualErr != nil:
+				if !strings.Contains(actualErr.Error(), tc.expectedErr) {
+					t.Errorf("expected %v, got %v", tc.expectedErr, actualErr)
+				}
+			}
+			if tc.expectedMsg != actualMsg {
+				t.Errorf("expected %v, got %v", tc.expectedMsg, actualMsg)
+			}
+			if tc.expectedAllowed != actualAllowed {
+				t.Errorf("expected %v, got %v", tc.expectedAllowed, actualAllowed)
+			}
+		})
+	}
+}
-- 
2.49.0

