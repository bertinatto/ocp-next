From cfb3b721b5b1e40c6754decf746ac459e5daeabd Mon Sep 17 00:00:00 2001
From: Fabio Bertinatto <fbertina@redhat.com>
Date: Tue, 22 Apr 2025 09:27:26 -0300
Subject: [PATCH] UPSTREAM: 131361: Wait for resource quota status to be
 populated

Trying to create a pod using a resourcequota whose status has not been
populated will result in api admission rejecting it with a 403
Forbidden. The pod resize tests do not wait/check to make sure the
resourcequota status is populated before trying to use the quota when
creating a pod, so in scenarious where either the test runs too fast, or
the resourcequota controller is too slow, the tests will fail.

This just makes the test wait up to a minute for the quota status to
populate. The status generation timing/logic gets tested separately in
test/e2e/apimachinery/resource_quota.go, and it waits a minute, so we
wait a minute, but in practice it takes at worst seconds.
---
 test/e2e/node/pod_resize.go | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/test/e2e/node/pod_resize.go b/test/e2e/node/pod_resize.go
index ae072f71412..4035bddf758 100644
--- a/test/e2e/node/pod_resize.go
+++ b/test/e2e/node/pod_resize.go
@@ -26,6 +26,8 @@ import (
 	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/wait"
+	clientset "k8s.io/client-go/kubernetes"
 	helpers "k8s.io/component-helpers/resource"
 	resourceapi "k8s.io/kubernetes/pkg/api/v1/resource"
 	"k8s.io/kubernetes/pkg/features"
@@ -64,6 +66,11 @@ func doPodResizeAdmissionPluginsTests() {
 				ginkgo.By("Creating a ResourceQuota")
 				_, rqErr := f.ClientSet.CoreV1().ResourceQuotas(f.Namespace.Name).Create(ctx, &resourceQuota, metav1.CreateOptions{})
 				framework.ExpectNoError(rqErr, "failed to create resource quota")
+				// pod creation using this quota will fail until the quota status is populated, so we need to wait to
+				// prevent races with the resourcequota controller
+				quotaStatusErr := waitForResourceQuota(ctx, f.ClientSet, f.Namespace.Name, resourceQuota.Name, v1.ResourceList{})
+				framework.ExpectNoError(quotaStatusErr)
+
 			},
 			wantMemoryError: "exceeded quota: resize-resource-quota, requested: memory=350Mi, used: memory=700Mi, limited: memory=800Mi",
 			wantCPUError:    "exceeded quota: resize-resource-quota, requested: cpu=200m, used: cpu=700m, limited: cpu=800m",
@@ -453,3 +460,19 @@ var _ = SIGDescribe("Pod InPlace Resize Container", framework.WithFeatureGate(fe
 	})
 	doPodResizeAdmissionPluginsTests()
 })
+
+func waitForResourceQuota(ctx context.Context, c clientset.Interface, ns, quotaName string, used v1.ResourceList) error {
+	return wait.PollUntilContextTimeout(ctx, framework.Poll, time.Minute, false, func(ctx context.Context) (bool, error) {
+		resourceQuota, err := c.CoreV1().ResourceQuotas(ns).Get(ctx, quotaName, metav1.GetOptions{})
+		if err != nil {
+			return false, err
+		}
+		// used may not yet be calculated
+		if resourceQuota.Status.Used == nil {
+			return false, nil
+		}
+
+		framework.Logf("Resource quota status for %s has been populated", quotaName)
+		return true, nil
+	})
+}
-- 
2.49.0

