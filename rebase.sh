#!/bin/bash

set -eo pipefail

main() {
    local branch_name="ocp-next"
    local should_update=false
    local should_commit=false
    local should_push=false

    while getopts "l:g:c:p:" opt; do
        case $opt in
            l)
                branch_name=${OPTARG}
                ;;
            g)
                should_update=${OPTARG}
                ;;
            c)
                should_commit=${OPTARG}
                ;;
            p)
                should_commit=${OPTARG}
                should_push=${OPTARG}
                ;;
	    *)
		true # Do nothing
		;;
        esac
    done

    setup_go
    setup_git
    clone_upstream_repo
    # The remaining commands are meant to run inside the kubernetes directory, so enter it
    pushd kubernetes || exit 1
    add_openshift_remote
    create_local_branch "$branch_name"
    merge_openshift_master
    apply_patches
    if $should_update; then
	update_dependencies
	update_vendor
        update_generated
    fi
    if $should_push; then
	commit
        push
    elif $should_commit; then
	commit
    fi
    popd
}

setup_go() {
    eval "$(gimme 1.20.3)"
    export FORCE_HOST_GO=1
}

setup_git() {
    git config --global user.email "fbertina@redhat.com"
    git config --global user.name "Fabio Bertinatto"
}

clone_upstream_repo() {
    # Clone upstream repo, if it doesn't exist yet
    git clone --origin upstream "https://github.com/kubernetes/kubernetes.git" || true
    # Make sure we have the latest code from master
    pushd kubernetes || exit 1
    git fetch upstream master
    popd
}

add_openshift_remote() {
    # Add openshift remote and make sure it's updated
    git remote add openshift "https://github.com/openshift/kubernetes.git" || true
    git fetch openshift master
}

create_local_branch() {
    local branch_name="$1"
    # Make sure the repo is clean
    git clean -fd && git checkout -- .
    git checkout -B "$branch_name" upstream/master
}

merge_openshift_master() {
    git merge -s ours --no-edit openshift/master
}

apply_patches() {
    local patch
    echo "Starting to apply patches"
    for patch in ../patches/*.patch; do
        if ! git am --3way "$patch"; then
            echo "Failed to apply $patch"
	    exit 1
        else
            echo "Applied $patch"
        fi
    done
}

update_dependencies() {
    GOPROXY=direct hack/pin-dependency.sh github.com/onsi/ginkgo/v2=github.com/openshift/onsi-ginkgo/v2 v2.9-openshift-4.14
    GOPROXY=direct hack/pin-dependency.sh github.com/openshift/api=github.com/bertinatto/api ocp-next
    GOPROXY=direct hack/pin-dependency.sh github.com/openshift/client-go=github.com/bertinatto/client-go ocp-next
    GOPROXY=direct hack/pin-dependency.sh github.com/openshift/library-go=github.com/bertinatto/library-go ocp-next
    GOPROXY=direct hack/pin-dependency.sh github.com/openshift/apiserver-library-go=github.com/bertinatto/apiserver-library-go ocp-next
}

update_vendor() {
    hack/update-vendor.sh
}

update_generated() {
    eval "$(hack/install-etcd.sh | grep "export PATH")"
    make clean && make update
}

commit() {
    git add .
    git commit -m "UPSTREAM: <drop>: update dependencies and generated files"
}

push() {
    git remote add origin "git@github.com:bertinatto/kubernetes.git" || true
    git push origin -u HEAD -f
    gh repo set-default openshift/kubernetes
    gh pr create --fill --draft --repo openshift/kubernetes --base master --title "[WIP] DO NOT MERGE: Update to tip of kubernetes/kubernetes" --body "Auto-generated by https://github.com/bertinatto/ocp-next."    
}

if [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
    main "$@"
fi
